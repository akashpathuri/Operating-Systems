//eeeeeeeeexxxxxxxxxxxxaaaaaaaammmmmmmmmmpppppppppppppllllllleeeee
	// if(thread_count == 0){
		
	// 	// ucontext_t *main_context = NULL;
	// 	// main_context = (ucontext_t*)malloc(sizeof(ucontext_t));

    //     // if (getcontext(main_context) == -1){
    //     //     perror("getcontext: could not get parent context\n");
    //     //     exit(1);
    //     // }
	// 	ucontext_t main_context;
	// 	getcontext(&main_context);

	// 	if(thread_count == 0){
	// 		ucontext_t new_context;
	// 		//ucontext_t* context = {0};
	// 		if (getcontext(&new_context) == -1){
	// 			perror("getcontext: could not get parent context\n");
	// 			exit(1);
	// 		}
	// 		new_context.uc_link = 0;
	// 		new_context.uc_stack.ss_sp = malloc(STACK_SIZE);
	// 		new_context.uc_stack.ss_size = STACK_SIZE;
	// 		new_context.uc_stack.ss_flags = 0;
	// 		if(new_context.uc_stack.ss_sp == 0){
	// 			perror("malloc: could not allocate stack");
	// 			return -1;
	// 		}//remove if not used
	// 		makecontext(&new_context,(void *)function, 1, arg);
	// 		tcb *new_thread = (tcb*) malloc(sizeof(tcb));
	// 		memset(new_thread, 0, sizeof(tcb));
	// 		*thread = ++thread_count;
	// 		new_thread->id = thread_count;
	// 		new_thread->context = &new_context;
	// 		new_thread->status = READY;
	// 		new_thread->priority = 0;
	// 		new_thread->next_thread = NULL; 

	// 		main_thread = (tcb*) malloc(sizeof(tcb));
	// 		memset(main_thread, 0, sizeof(tcb));
	// 		main_thread->id = 0;
	// 		main_thread->context = &main_context;
	// 		main_thread->status = RUNNING;
	// 		main_thread->priority = 0;
	// 		main_thread->next_thread = NULL;
		

	// 		//initilize ready queue...........
	// 		for(int x = 0; x<PRIORITY_LEVELS; x++){
	// 			//create_queue(ready_queue[x]);
	// 			memset(&ready_queue[x], 0, sizeof(thread_queue));
	// 			ready_queue[x].size = 0;
	// 		}
	// 		current_node = main_thread;
	// 		ready_queue[0] = enqueue(main_thread, &ready_queue[0]);
	// 		ready_queue[0] = enqueue(new_thread, &ready_queue[0]);
	// 		printf("Thread %d \n", ready_queue[0].last_node->id);
	// 		//swapcontext(&main_context, &new_context);
	// 		create_timer();
	// 		schedule();
	// 	}

	// }else{
	// 	ucontext_t *context = (ucontext_t*)malloc(sizeof(ucontext_t));
	// 	//ucontext_t* context = {0};
	// 	if (getcontext(context) == -1){
	// 		perror("getcontext: could not get parent context\n");
	// 		exit(1);
	// 	}
	// 	context->uc_link = 0;
	// 	context->uc_stack.ss_sp = malloc(STACK_SIZE);
	// 	context->uc_stack.ss_size = STACK_SIZE;
	// 	context->uc_stack.ss_flags = 0;
	// 	if(context->uc_stack.ss_sp == 0){
	// 		perror("malloc: could not allocate stack");
	// 		return -1;
	// 	}//remove if not used
		
	// 	makecontext(context,(void *)function, 1, arg);
	// 	tcb *new_thread = (tcb*) malloc(sizeof(tcb));
	// 	memset(new_thread, 0, sizeof(tcb));
	// 	*thread = ++thread_count;
	// 	new_thread->id = thread_count;
	// 	new_thread->context = context;
	// 	new_thread->status = READY;
	// 	new_thread->priority = 0;
	// 	new_thread->next_thread = NULL; 
	// 	ready_queue[0] = enqueue(new_thread, &ready_queue[0]);
	// }